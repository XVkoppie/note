# js数据类型

- 原始类型
    + number
    + string
    + boolean
    + Undefined
    + Null

    新增
    + Symbol
    + BigInt
- 复杂类型(引用类型)    
    + object

## 判断数据类型

```js
const a=100                 //typeof a = number
const b=undefined           //typeof b = undefined
const c=null                //typeof c = object
const d=[1,2,3]             //typeof d = object
const e=function(){}        //typeof e = function
const f =new Number(123)    //typeof f = object
```
```js
console.log(Object.prototype.toString.call(a)) // object Number
console.log(Object.prototype.toString.call(b)) // object Undefined 
console.log(Object.prototype.toString.call(c)) // object Null
console.log(Object.prototype.toString.call(d)) // object Array
console.log(Object.prototype.toString.call(e)) // object Function
console.log(Object.prototype.toString.call(f)) // object Number
``` 
所以判断步骤：
1. 判断是不是null
2. 使用typeof判断出原型对象
3. Object.prototype.toString.call() 判断剩下的objet   

好的，这是一个非常经典的面试题。你可以按照以下思路，分层次、有条理地进行口语化回答。

**核心思路：** 先总述分类，再分步讲解判断方法，最后总结一个“最佳实践”流程。

---

### 口语化回答参考：

“关于JavaScript的数据类型和判断方式，我是这样理解和处理的。”

**首先，JS的数据类型主要分为两大类：**

1.  **原始类型（基本类型）**：包括最基础的 `Number`、`String`、`Boolean`，以及特殊的 `Undefined` 和 `Null`。ES6之后又新增了 `Symbol` 和 `BigInt`。
2.  **复杂类型（引用类型）**：主要指 `Object`。像我们常见的数组 `Array`、函数 `Function`、日期 `Date` 等，本质上都属于 `Object` 类型。

**然后，关于如何判断这些类型，我们有几个常用的工具，但它们各有优劣。**

1.  **第一个是 `typeof` 操作符**，它用起来最方便，但对于某些类型的判断结果会有些“坑”。
    *   比如，对大部分原始类型它工作得很好：`typeof 123` 是 `"number"`，`typeof 'abc'` 是 `"string"`，`typeof undefined` 是 `"undefined"`。
    *   但它有两个著名的特殊情况：
        *   **`typeof null` 的结果是 `"object"`**。这是一个历史遗留的Bug，所以我们不能用 `typeof` 来判断 `null`。
        *   对于函数，`typeof function(){}` 会返回 `"function"`，这算是个有用的特性。但对于其他所有对象，比如数组、普通对象、包装对象等，`typeof` 统一都返回 `"object"`，无法做更细致的区分。

2.  **第二个是 `Object.prototype.toString.call()` 方法**，这是一个非常强大和准确的方法。它会返回一个格式为 `[object Xxx]` 的字符串，其中的 `Xxx` 就是精确的类型。
    *   比如：
        *   `Object.prototype.toString.call([])` 返回 `[object Array]`
        *   `Object.prototype.toString.call(null)` 返回 `[object Null]`
        *   `Object.prototype.toString.call(new Date())` 返回 `[object Date]`
    *   这个方法几乎可以准确区分所有内置类型，是类型判断的“终极武器”。

**所以，在实际开发或者面试中，如果我需要实现一个可靠的类型判断函数，我的思路通常是这样的：**

**第一步，先判断是否为 `null`。**
因为 `typeof null` 是 `object`，需要优先把它排除掉。

**第二步，使用 `typeof` 判断出非对象的类型。**
如果 `typeof` 的结果是 `"number"`, `"string"`, `"boolean"`, `"undefined"`, `"symbol"`, `"bigint"`，或者 `"function"`，那我就可以直接得出结果了。

**第三步，对于剩下的、`typeof` 结果是 `"object"` 的情况，我再使用 `Object.prototype.toString.call()` 来进行精确的判断。**
比如区分它是 `Array`、`Date`、`RegExp` 还是普通的 `Object`。

**总结一下**，没有一种方法能完美通吃所有情况，但通过 `typeof` 和 `Object.prototype.toString` 的组合，并优先处理 `null` 这个特例，我们就可以准确地判断出任何数据的类型。”

---

### 加分项（如果面试官深入追问）：

*   **提到 `instanceof`**：可以补充说，“还有一个 `instanceof` 运算符，它主要用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上，适合用来判断自定义的对象实例，但对于原始类型和不同窗口（如iframe）内的对象判断可能不准确。”
*   **提到 `Array.isArray()`**： “对于数组判断，现在更推荐使用ES5提供的 `Array.isArray()` 方法，它非常专门和可靠。”

这样回答，既展现了你的知识广度（知道所有方法），也体现了你的深度（理解各种方法的原理和缺陷），并且给出了一个严谨、实用的解决方案，会给面试官留下很好的印象。